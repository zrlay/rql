{"version":3,"sources":["webpack:///webpack/bootstrap 428b19b48feb862216d9","webpack:///./parser.js","webpack:///./angularjs/rql.js","webpack:///./util/contains.js","webpack:///./query.js","webpack:///./util/each.js","webpack:///./node_modules/promised-io/promise.js","webpack:///(webpack)/buildin/amd-define.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AC7DA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,UAAU,IAAI;AACxF;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,sBAAsB,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,UAAU,IAAI;AAC9E;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA,4DAA4D,0CAA0C,eAAe;AACrH,2CAA2C;AAC3C,kDAAkD;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA;;;;;;;ACpSD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;;;;;;gEChBD;AACA;;AAEA;AACA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA;;;;;;;ACVD;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI,iEAAiE,gFAAgF;AACrJ;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD,kCAAkC;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,gDAAgD;AACpI;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,OAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE;AACF;AACA;;AAEA;AACA,CAAC;AAAA;;;;;;;gEC7QD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA;;;;;;;ACnBD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,CAAC;AACD;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB,WAAW;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA;AACD,CAAC,wBAA+E;;;;;;;ACztBhF;AACA;AACA","file":"rql.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 428b19b48feb862216d9","/**\n * This module provides RQL parsing. For example:\n * var parsed = require(\"./parser\").parse(\"b=3&le(c,5)\");\n */\ndefine([\"exports\", \"./util/contains\"], function(exports, contains){\n\nvar operatorMap = {\n\t\"=\": \"eq\",\n\t\"==\": \"eq\",\n\t\">\": \"gt\",\n\t\">=\": \"ge\",\n\t\"<\": \"lt\",\n\t\"<=\": \"le\",\n\t\"!=\": \"ne\"\n};\n\n\nexports.primaryKeyName = 'id';\nexports.lastSeen = ['sort', 'select', 'values', 'limit'];\nexports.jsonQueryCompatible = true;\n\nfunction parse(/*String|Object*/query, parameters){\n\tif (typeof query === \"undefined\" || query === null)\n\t\tquery = '';\n\tvar term = new exports.Query();\n\tvar topTerm = term;\n\ttopTerm.cache = {}; // room for lastSeen params\n\tvar topTermName = topTerm.name;\n\ttopTerm.name = '';\n\tif(typeof query === \"object\"){\n\t\tif(query instanceof exports.Query){\n\t\t\treturn query;\n\t\t}\n\t\tfor(var i in query){\n\t\t\tvar term = new exports.Query();\n\t\t\ttopTerm.args.push(term);\n\t\t\tterm.name = \"eq\";\n\t\t\tterm.args = [i, query[i]];\n\t\t}\n\t\treturn topTerm;\n\t}\n\tif(query.charAt(0) === \"?\"){\n\t\tthrow new URIError(\"Query must not start with ?\");\n\t}\n\tif(exports.jsonQueryCompatible){\n\t\tquery = query.replace(/%3C=/g,\"=le=\").replace(/%3E=/g,\"=ge=\").replace(/%3C/g,\"=lt=\").replace(/%3E/g,\"=gt=\");\n\t}\n\tif(query.indexOf(\"/\") > -1){ // performance guard\n\t\t// convert slash delimited text to arrays\n\t\tquery = query.replace(/[\\+\\*\\$\\-:\\w%\\._]*\\/[\\+\\*\\$\\-:\\w%\\._\\/]*/g, function(slashed){\n\t\t\treturn \"(\" + slashed.replace(/\\//g, \",\") + \")\";\n\t\t});\n\t}\n\t// convert FIQL to normalized call syntax form\n\tquery = query.replace(/(\\([\\+\\*\\$\\-:\\w%\\._,]+\\)|[\\+\\*\\$\\-:\\w%\\._]*|)([<>!]?=(?:[\\w]*=)?|>|<)(\\([\\+\\*\\$\\-:\\w%\\._,]+\\)|[\\+\\*\\$\\-:\\w%\\._]*|)/g,\n\t\t\t\t\t\t// <---------       property        -----------><------  operator -----><----------------   value ------------------>\n\t\t\tfunction(t, property, operator, value){\n\t\tif(operator.length < 3){\n\t\t\tif(!operatorMap[operator]){\n\t\t\t\tthrow new URIError(\"Illegal operator \" + operator);\n\t\t\t}\n\t\t\toperator = operatorMap[operator];\n\t\t}\n\t\telse{\n\t\t\toperator = operator.substring(1, operator.length - 1);\n\t\t}\n\t\treturn operator + '(' + property + \",\" + value + \")\";\n\t});\n\tif(query.charAt(0)===\"?\"){\n\t\tquery = query.substring(1);\n\t}\n\tvar leftoverCharacters = query.replace(/(\\))|([&\\|,])?([\\+\\*\\$\\-:\\w%\\._]*)(\\(?)/g,\n\t\t\t\t\t\t\t//   <-closedParan->|<-delim-- propertyOrValue -----(> |\n\t\tfunction(t, closedParan, delim, propertyOrValue, openParan){\n\t\t\tif(delim){\n\t\t\t\tif(delim === \"&\"){\n\t\t\t\t\tsetConjunction(\"and\");\n\t\t\t\t}\n\t\t\t\tif(delim === \"|\"){\n\t\t\t\t\tsetConjunction(\"or\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(openParan){\n\t\t\t\tvar newTerm = new exports.Query();\n\t\t\t\tnewTerm.name = propertyOrValue;\n\t\t\t\tnewTerm.parent = term;\n\t\t\t\tcall(newTerm);\n\t\t\t}\n\t\t\telse if(closedParan){\n\t\t\t\tvar isArray = !term.name;\n\t\t\t\tterm = term.parent;\n\t\t\t\tif(!term){\n\t\t\t\t\tthrow new URIError(\"Closing paranthesis without an opening paranthesis\");\n\t\t\t\t}\n\t\t\t\tif(isArray){\n\t\t\t\t\tterm.args.push(term.args.pop().args);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(propertyOrValue || delim === ','){\n\t\t\t\tterm.args.push(stringToValue(propertyOrValue, parameters));\n\n\t\t\t\t// cache the last seen sort(), select(), values() and limit()\n\t\t\t\tif (contains(exports.lastSeen, term.name)) {\n\t\t\t\t\ttopTerm.cache[term.name] = term.args;\n\t\t\t\t}\n\t\t\t\t// cache the last seen id equality\n\t\t\t\tif (term.name === 'eq' && term.args[0] === exports.primaryKeyName) {\n\t\t\t\t\tvar id = term.args[1];\n\t\t\t\t\tif (id && !(id instanceof RegExp)) id = id.toString();\n\t\t\t\t\ttopTerm.cache[exports.primaryKeyName] = id;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn \"\";\n\t\t});\n\tif(term.parent){\n\t\tthrow new URIError(\"Opening paranthesis without a closing paranthesis\");\n\t}\n\tif(leftoverCharacters){\n\t\t// any extra characters left over from the replace indicates invalid syntax\n\t\tthrow new URIError(\"Illegal character in query string encountered \" + leftoverCharacters);\n\t}\n\n\tfunction call(newTerm){\n\t\tterm.args.push(newTerm);\n\t\tterm = newTerm;\n\t\t// cache the last seen sort(), select(), values() and limit()\n\t\tif (contains(exports.lastSeen, term.name)) {\n\t\t\ttopTerm.cache[term.name] = term.args;\n\t\t}\n\t}\n\tfunction setConjunction(operator){\n\t\tif(!term.name){\n\t\t\tterm.name = operator;\n\t\t}\n\t\telse if(term.name !== operator){\n\t\t\tthrow new Error(\"Can not mix conjunctions within a group, use paranthesis around each set of same conjuctions (& and |)\");\n\t\t}\n\t}\n\tfunction removeParentProperty(obj) {\n\t\tif(obj && obj.args){\n\t\t\tdelete obj.parent;\n\t\t\tvar args = obj.args;\n\t\t\tfor(var i = 0, l = args.length; i < l; i++){\n\t\t\t\tremoveParentProperty(args[i]);\n\t\t\t}\n\t\t}\n\t\treturn obj;\n\t};\n\tremoveParentProperty(topTerm);\n\tif (!topTerm.name) {\n\t\ttopTerm.name = topTermName;\n\t}\n\treturn topTerm;\n};\n\nexports.parse = exports.parseQuery = parse;\n\n/* dumps undesirable exceptions to Query().error */\nexports.parseGently = function(){\n\tvar terms;\n\ttry {\n\t\tterms = parse.apply(this, arguments);\n\t} catch(err) {\n\t\tterms = new exports.Query();\n\t\tterms.error = err.message;\n\t}\n\treturn terms;\n}\n\nexports.commonOperatorMap = {\n\t\"and\" : \"&\",\n\t\"or\" : \"|\",\n\t\"eq\" : \"=\",\n\t\"ne\" : \"!=\",\n\t\"le\" : \"<=\",\n\t\"ge\" : \">=\",\n\t\"lt\" : \"<\",\n\t\"gt\" : \">\"\n}\nfunction stringToValue(string, parameters){\n\tvar converter = exports.converters['default'];\n\tif(string.charAt(0) === \"$\"){\n\t\tvar param_index = parseInt(string.substring(1)) - 1;\n\t\treturn param_index >= 0 && parameters ? parameters[param_index] : undefined;\n\t}\n\tif(string.indexOf(\":\") > -1){\n\t\tvar parts = string.split(\":\");\n\t\tconverter = exports.converters[parts[0]];\n\t\tif(!converter){\n\t\t\tthrow new URIError(\"Unknown converter \" + parts[0]);\n\t\t}\n\t\tstring = parts.slice(1).join(':');\n\t}\n\treturn converter(string);\n};\n\nvar autoConverted = exports.autoConverted = {\n\t\"true\": true,\n\t\"false\": false,\n\t\"null\": null,\n\t\"undefined\": undefined,\n\t\"Infinity\": Infinity,\n\t\"-Infinity\": -Infinity\n};\n\nexports.converters = {\n\tauto: function(string){\n\t\tif(autoConverted.hasOwnProperty(string)){\n\t\t\treturn autoConverted[string];\n\t\t}\n\t\tvar number = +string;\n\t\tif(isNaN(number) || number.toString() !== string){\n          /*var isoDate = /^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d{1,3}))?Z$/.exec(x);\n          if (isoDate) {\n            date = new Date(Date.UTC(+isoDate[1], +isoDate[2] - 1, +isoDate[3], +isoDate[4], +isoDate[5], +isoDate[6], +isoDate[7] || 0));\n          }*/\n\t\t\tstring = decodeURIComponent(string);\n\t\t\tif(exports.jsonQueryCompatible){\n\t\t\t\tif(string.charAt(0) == \"'\" && string.charAt(string.length-1) == \"'\"){\n\t\t\t\t\treturn JSON.parse('\"' + string.substring(1,string.length-1) + '\"');\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn string;\n\t\t}\n\t\treturn number;\n\t},\n\tnumber: function(x){\n\t\tvar number = +x;\n\t\tif(isNaN(number)){\n\t\t\tthrow new URIError(\"Invalid number \" + number);\n\t\t}\n\t\treturn number;\n\t},\n\tepoch: function(x){\n\t\tvar date = new Date(+x);\n\t\tif (isNaN(date.getTime())) {\n\t\t\tthrow new URIError(\"Invalid date \" + x);\n\t\t}\n\t\treturn date;\n\t},\n\tisodate: function(x){\n\t\t// four-digit year\n\t\tvar date = '0000'.substr(0,4-x.length)+x;\n\t\t// pattern for partial dates\n\t\tdate += '0000-01-01T00:00:00Z'.substring(date.length);\n\t\treturn exports.converters.date(date);\n\t},\n\tdate: function(x){\n\t\tvar isoDate = /^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d{1,3}))?Z$/.exec(x);\n\t\tvar date;\n\t\tif (isoDate) {\n\t\t\tdate = new Date(Date.UTC(+isoDate[1], +isoDate[2] - 1, +isoDate[3], +isoDate[4], +isoDate[5], +isoDate[6], +isoDate[7] || 0));\n\t\t}else{\n\t\t\tdate = new Date(x);\n\t\t}\n\t\tif (isNaN(date.getTime())){\n\t\t\tthrow new URIError(\"Invalid date \" + x);\n\t\t}\n\t\treturn date;\n\t},\n\t\"boolean\": function(x){\n\t\treturn x === \"true\";\n\t},\n\tstring: function(string){\n\t\treturn decodeURIComponent(string);\n\t},\n\tre: function(x){\n\t\treturn new RegExp(decodeURIComponent(x), 'i');\n\t},\n\tRE: function(x){\n\t\treturn new RegExp(decodeURIComponent(x));\n\t},\n\tglob: function(x){\n\t\tvar s = decodeURIComponent(x).replace(/([\\\\|\\||\\(|\\)|\\[|\\{|\\^|\\$|\\*|\\+|\\?|\\.|\\<|\\>])/g, function(x){return '\\\\'+x;}).replace(/\\\\\\*/g,'.*').replace(/\\\\\\?/g,'.?');\n\t\tif (s.substring(0,2) !== '.*') s = '^'+s; else s = s.substring(2);\n\t\tif (s.substring(s.length-2) !== '.*') s = s+'$'; else s = s.substring(0, s.length-2);\n\t\treturn new RegExp(s, 'i');\n\t}\n};\n\n// exports.converters[\"default\"] can be changed to a different converter if you want\n// a different default converter, for example:\n// RP = require(\"rql/parser\");\n// RP.converters[\"default\"] = RQ.converter.string;\nexports.converters[\"default\"] = exports.converters.auto;\n\n// this can get replaced by the chainable query if query.js is loaded\nexports.Query = function(){\n\tthis.name = \"and\";\n\tthis.args = [];\n};\nreturn exports;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./parser.js\n// module id = 0\n// module chunks = 0 1","/*global angular,window*/\n\n(function withAngular(angular, window) {\n  \"use strict\";\n\n  var parserProvider = function parserProvider() {\n    return require(\"../parser\");\n  };\n  var queryProvider = function queryProvider() {\n    return require(\"../query\");\n  };\n\n  angular\n    .module(\"rql\", [])\n    .factory(\"rqlParser\", parserProvider)\n    .factory(\"rqlQuery\", queryProvider);\n})(angular, window);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./angularjs/rql.js\n// module id = 1\n// module chunks = 0 1","define([], function(){\nreturn contains;\n\nfunction contains(array, item){\n\tfor(var i = 0, l = array.length; i < l; i++){\n\t\tif(array[i] === item){\n\t\t\treturn true;\n\t\t}\n\t}\n}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./util/contains.js\n// module id = 2\n// module chunks = 0 1","/**\n * Provides a Query constructor with chainable capability. For example:\n * var Query = require(\"./query\").Query;\n * query = Query();\n * query.executor = function(query){\n *\t\trequire(\"./js-array\").query(query, params, data); // if we want to operate on an array\n * };\n * query.eq(\"a\", 3).le(\"b\", 4).forEach(function(object){\n *\t // for each object that matches the query\n * });\n */\n//({define:typeof define!=\"undefined\"?define:function(deps, factory){module.exports = factory(exports, require(\"./parser\"), require(\"./js-array\"));}}).\n//define([\"exports\", \"./parser\", \"./js-array\"], function(exports, parser, jsarray){\ndefine([\"exports\", \"./parser\", \"./util/each\"], function(exports, parser, each){\n\nvar parseQuery = parser.parseQuery;\ntry{\n\tvar when = require(\"promised-io/promise\").when;\n}catch(e){\n\twhen = function(value, callback){callback(value)};\n}\n\nparser.Query = function(seed, params){\n\tif (typeof seed === 'string')\n\t\treturn parseQuery(seed, params);\n\tvar q = new Query();\n\tif (seed && seed.name && seed.args)\n\t\tq.name = seed.name, q.args = seed.args;\n\treturn q;\n};\nexports.Query = parser.Query;\n//TODO:THE RIGHT WAY IS:exports.knownOperators = Object.keys(jsarray.operators || {}).concat(Object.keys(jsarray.jsOperatorMap || {}));\nexports.knownOperators = [\"sort\", \"match\", \"in\", \"out\", \"or\", \"and\", \"select\", \"contains\", \"excludes\", \"values\", \"limit\", \"distinct\", \"recurse\", \"aggregate\", \"between\", \"sum\", \"mean\", \"max\", \"min\", \"count\", \"first\", \"one\", \"eq\", \"ne\", \"le\", \"ge\", \"lt\", \"gt\"];\nexports.knownScalarOperators = [\"mean\", \"sum\", \"min\", \"max\", \"count\", \"first\", \"one\"];\nexports.arrayMethods = [\"forEach\", \"reduce\", \"map\", \"filter\", \"indexOf\", \"some\", \"every\"];\n\nfunction Query(name){\n\tthis.name = name || \"and\";\n\tthis.args = [];\n}\nfunction serializeArgs(array, delimiter){\n\tvar results = [];\n\tfor(var i = 0, l = array.length; i < l; i++){\n\t\tresults.push(queryToString(array[i]));\n\t}\n\treturn results.join(delimiter);\n}\nexports.Query.prototype = Query.prototype;\nQuery.prototype.toString = function(){\n\treturn this.name === \"and\" ?\n\t\tserializeArgs(this.args, \"&\") :\n\t\tqueryToString(this);\n};\n\nfunction queryToString(part) {\n\t\tif (part instanceof Array) {\n\t\t\t\treturn '(' + serializeArgs(part, \",\")+')';\n\t\t}\n\t\tif (part && part.name && part.args) {\n\t\t\t\treturn [\n\t\t\t\t\t\tpart.name,\n\t\t\t\t\t\t\"(\",\n\t\t\t\t\t\tserializeArgs(part.args, \",\"),\n\t\t\t\t\t\t\")\"\n\t\t\t\t].join(\"\");\n\t\t}\n\t\treturn exports.encodeValue(part);\n};\n\nfunction encodeString(s) {\n\t\tif (typeof s === \"string\") {\n\t\t\t\ts = encodeURIComponent(s);\n\t\t\t\tif (s.match(/[\\(\\)]/)) {\n\t\t\t\t\t\ts = s.replace(\"(\",\"%28\").replace(\")\",\"%29\");\n\t\t\t\t};\n\t\t}\n\t\treturn s;\n}\n\nexports.encodeValue = function(val) {\n\t\tvar encoded;\n\t\tif (val === null) val = 'null';\n\t\tif (val !== parser.converters[\"default\"]('' + (\n\t\t\t\tval.toISOString && val.toISOString() || val.toString()\n\t\t))) {\n\t\t\t\tvar type = typeof val;\n\t\t\t\tif(val instanceof RegExp){\n\t\t\t\t\t// TODO: control whether to we want simpler glob() style\n\t\t\t\t\tval = val.toString();\n\t\t\t\t\tvar i = val.lastIndexOf('/');\n\t\t\t\t\ttype = val.substring(i).indexOf('i') >= 0 ? \"re\" : \"RE\";\n\t\t\t\t\tval = encodeString(val.substring(1, i));\n\t\t\t\t\tencoded = true;\n\t\t\t\t}\n\t\t\t\tif(type === \"object\"){\n\t\t\t\t\t\ttype = \"epoch\";\n\t\t\t\t\t\tval = val.getTime();\n\t\t\t\t\t\tencoded = true;\n\t\t\t\t}\n\t\t\t\tif(type === \"string\") {\n\t\t\t\t\t\tval = encodeString(val);\n\t\t\t\t\t\tencoded = true;\n\t\t\t\t}\n\t\t\t\tval = [type, val].join(\":\");\n\t\t}\n\t\tif (!encoded && typeof val === \"string\") val = encodeString(val);\n\t\treturn val;\n};\n\nexports.updateQueryMethods = function(){\n\teach(exports.knownOperators, function(name){\n\t\tQuery.prototype[name] = function(){\n\t\t\tvar newQuery = new Query();\n\t\t\tnewQuery.executor = this.executor;\n\t\t\tvar newTerm = new Query(name);\n\t\t\tnewTerm.args = Array.prototype.slice.call(arguments);\n\t\t\tnewQuery.args = this.args.concat([newTerm]);\n\t\t\treturn newQuery;\n\t\t};\n\t});\n\teach(exports.knownScalarOperators, function(name){\n\t\tQuery.prototype[name] = function(){\n\t\t\tvar newQuery = new Query();\n\t\t\tnewQuery.executor = this.executor;\n\t\t\tvar newTerm = new Query(name);\n\t\t\tnewTerm.args = Array.prototype.slice.call(arguments);\n\t\t\tnewQuery.args = this.args.concat([newTerm]);\n\t\t\treturn newQuery.executor(newQuery);\n\t\t};\n\t});\n\teach(exports.arrayMethods, function(name){\n\t\t// this makes no guarantee of ensuring that results supports these methods\n\t\tQuery.prototype[name] = function(){\n\t\t\tvar args = arguments;\n\t\t\treturn when(this.executor(this), function(results){\n\t\t\t\treturn results[name].apply(results, args);\n\t\t\t});\n\t\t};\n\t});\n\n};\n\nexports.updateQueryMethods();\n\n/* recursively iterate over query terms calling 'fn' for each term */\nQuery.prototype.walk = function(fn, options){\n\toptions = options || {};\n\tfunction walk(name, terms){\n\t\tterms = terms || [];\n\n\t\tvar i = 0,\n\t\t\tl = terms.length,\n\t\t\tterm,\n\t\t\targs,\n\t\t\tfunc,\n\t\t\tnewTerm;\n\n\t\tfor (; i < l; i++) {\n\t\t\tterm = terms[i];\n\t\t\tif (term == null) {\n\t\t\t\tterm = {};\n\t\t\t}\n\t\t\tfunc = term.name;\n\t\t\targs = term.args;\n\t\t\tif (!func || !args) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (args[0] instanceof Query) {\n\t\t\t\twalk.call(this, func, args);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnewTerm = fn.call(this, func, args);\n\t\t\t\tif (newTerm && newTerm.name && newTerm.ags) {\n\t\t\t\t\tterms[i] = newTerm;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twalk.call(this, this.name, this.args);\n};\n\n/* append a new term */\nQuery.prototype.push = function(term){\n\tthis.args.push(term);\n\treturn this;\n};\n\n/* disambiguate query */\nQuery.prototype.normalize = function(options){\n\toptions = options || {};\n\toptions.primaryKey = options.primaryKey || 'id';\n\toptions.map = options.map || {};\n\tvar result = {\n\t\toriginal: this,\n\t\tsort: [],\n\t\tlimit: [Infinity, 0, Infinity],\n\t\tskip: 0,\n\t\tlimit: Infinity,\n\t\tselect: [],\n\t\tvalues: false\n\t};\n\tvar plusMinus = {\n\t\t// [plus, minus]\n\t\tsort: [1, -1],\n\t\tselect: [1, 0]\n\t};\n\tfunction normal(func, args){\n\t\t// cache some parameters\n\t\tif (func === 'sort' || func === 'select') {\n\t\t\tresult[func] = args;\n\t\t\tvar pm = plusMinus[func];\n\t\t\tresult[func+'Arr'] = result[func].map(function(x){\n\t\t\t\tif (x instanceof Array) x = x.join('.');\n\t\t\t\tvar o = {};\n\t\t\t\tvar a = /([-+]*)(.+)/.exec(x);\n\t\t\t\to[a[2]] = pm[(a[1].charAt(0) === '-')*1];\n\t\t\t\treturn o;\n\t\t\t});\n\t\t\tresult[func+'Obj'] = {};\n\t\t\tresult[func].forEach(function(x){\n\t\t\t\tif (x instanceof Array) x = x.join('.');\n\t\t\t\tvar a = /([-+]*)(.+)/.exec(x);\n\t\t\t\tresult[func+'Obj'][a[2]] = pm[(a[1].charAt(0) === '-')*1];\n\t\t\t});\n\t\t} else if (func === 'limit') {\n\t\t\t// validate limit() args to be numbers, with sane defaults\n\t\t\tvar limit = args;\n\t\t\tresult.skip = +limit[1] || 0;\n\t\t\tlimit = +limit[0] || 0;\n\t\t\tif (options.hardLimit && limit > options.hardLimit)\n\t\t\t\tlimit = options.hardLimit;\n\t\t\tresult.limit = limit;\n\t\t\tresult.needCount = true;\n\t\t} else if (func === 'values') {\n\t\t\t// N.B. values() just signals we want array of what we select()\n\t\t\tresult.values = true;\n\t\t} else if (func === 'eq') {\n\t\t\t// cache primary key equality -- useful to distinguish between .get(id) and .query(query)\n\t\t\tvar t = typeof args[1];\n\t\t\t//if ((args[0] instanceof Array ? args[0][args[0].length-1] : args[0]) === options.primaryKey && ['string','number'].indexOf(t) >= 0) {\n\t\t\tif (args[0] === options.primaryKey && ('string' === t || 'number' === t)) {\n\t\t\t\tresult.pk = String(args[1]);\n\t\t\t}\n\t\t}\n\t\t// cache search conditions\n\t\t//if (options.known[func])\n\t\t// map some functions\n\t\t/*if (options.map[func]) {\n\t\t\tfunc = options.map[func];\n\t\t}*/\n\t}\n\tthis.walk(normal);\n\treturn result;\n};\n\n/* FIXME: an example will be welcome\nQuery.prototype.toMongo = function(options){\n\treturn this.normalize({\n\t\tprimaryKey: '_id',\n\t\tmap: {\n\t\t\tge: 'gte',\n\t\t\tle: 'lte'\n\t\t},\n\t\tknown: ['lt','lte','gt','gte','ne','in','nin','not','mod','all','size','exists','type','elemMatch']\n\t});\n};\n*/\n\nreturn exports;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./query.js\n// module id = 3\n// module chunks = 0 1","define([], function(){\nreturn each;\n\nfunction each(array, callback){\n\tvar emit, result;\n\tif (callback.length > 1) {\n\t\t// can take a second param, emit\n\t\tresult = [];\n\t\temit = function(value){\n\t\t\tresult.push(value);\n\t\t};\n\t}\n\tfor(var i = 0, l = array.length; i < l; i++){\n\t\tif(callback(array[i], emit)){\n\t\t\treturn result || true;\n\t\t}\n\t}\n\treturn result;\n}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./util/each.js\n// module id = 4\n// module chunks = 0 1","(function(define){\r\ndefine(function(require,exports){\r\n\r\n// Kris Zyp\r\n\r\n// this is based on the CommonJS spec for promises:\r\n// http://wiki.commonjs.org/wiki/Promises\r\n// Includes convenience functions for promises, much of this is taken from Tyler Close's ref_send\r\n// and Kris Kowal's work on promises.\r\n// // MIT License\r\n\r\n// A typical usage:\r\n// A default Promise constructor can be used to create a self-resolving deferred/promise:\r\n// var Promise = require(\"promise\").Promise;\r\n//\tvar promise = new Promise();\r\n// asyncOperation(function(){\r\n//\tPromise.resolve(\"succesful result\");\r\n// });\r\n//\tpromise -> given to the consumer\r\n//\r\n//\tA consumer can use the promise\r\n//\tpromise.then(function(result){\r\n//\t\t... when the action is complete this is executed ...\r\n//\t },\r\n//\t function(error){\r\n//\t\t... executed when the promise fails\r\n//\t});\r\n//\r\n// Alternately, a provider can create a deferred and resolve it when it completes an action.\r\n// The deferred object a promise object that provides a separation of consumer and producer to protect\r\n// promises from being fulfilled by untrusted code.\r\n// var defer = require(\"promise\").defer;\r\n//\tvar deferred = defer();\r\n// asyncOperation(function(){\r\n//\tdeferred.resolve(\"succesful result\");\r\n// });\r\n//\tdeferred.promise -> given to the consumer\r\n//\r\n//\tAnother way that a consumer can use the promise (using promise.then is also allowed)\r\n// var when = require(\"promise\").when;\r\n// when(promise,function(result){\r\n//\t\t... when the action is complete this is executed ...\r\n//\t },\r\n//\t function(error){\r\n//\t\t... executed when the promise fails\r\n//\t});\r\n\r\nexports.errorTimeout = 100;\r\nvar freeze = Object.freeze || function(){};\r\n\r\n/**\r\n * Default constructor that creates a self-resolving Promise. Not all promise implementations\r\n * need to use this constructor.\r\n */\r\nvar Promise = function(canceller){\r\n};\r\n\r\n/**\r\n * Promise implementations must provide a \"then\" function.\r\n */\r\nPromise.prototype.then = function(resolvedCallback, errorCallback, progressCallback){\r\n\tthrow new TypeError(\"The Promise base class is abstract, this function must be implemented by the Promise implementation\");\r\n};\r\n\r\n/**\r\n * If an implementation of a promise supports a concurrency model that allows\r\n * execution to block until the promise is resolved, the wait function may be\r\n * added.\r\n */\r\n/**\r\n * If an implementation of a promise can be cancelled, it may add this function\r\n */\r\n // Promise.prototype.cancel = function(){\r\n // };\r\n\r\nPromise.prototype.get = function(propertyName){\r\n\treturn this.then(function(value){\r\n\t\treturn value[propertyName];\r\n\t});\r\n};\r\n\r\nPromise.prototype.put = function(propertyName, value){\r\n\treturn this.then(function(object){\r\n\t\treturn object[propertyName] = value;\r\n\t});\r\n};\r\n\r\nPromise.prototype.call = function(functionName /*, args */){\r\n\tvar fnArgs = Array.prototype.slice.call(arguments, 1);\r\n\treturn this.then(function(value){\r\n\t\treturn value[functionName].apply(value, fnArgs);\r\n\t});\r\n};\r\n\r\n/**\r\n * This can be used to conviently resolve a promise with auto-handling of errors:\r\n * setTimeout(deferred.resolverCallback(function(){\r\n *   return doSomething();\r\n * }), 100);\r\n */\r\nPromise.prototype.resolverCallback = function(callback){\r\n\tvar self = this;\r\n\treturn function(){\r\n\t\ttry{\r\n\t\t\tself.resolve(callback());\r\n\t\t}catch(e){\r\n\t\t\tself.reject(e);\r\n\t\t}\r\n\t}\r\n};\r\n\r\n/** Dojo/NodeJS methods*/\r\nPromise.prototype.addCallback = function(callback){\r\n\treturn this.then(callback);\r\n};\r\n\r\nPromise.prototype.addErrback = function(errback){\r\n\treturn this.then(function(){}, errback);\r\n};\r\n\r\n/*Dojo methods*/\r\nPromise.prototype.addBoth = function(callback){\r\n\treturn this.then(callback, callback);\r\n};\r\n\r\nPromise.prototype.addCallbacks = function(callback, errback){\r\n\treturn this.then(callback, errback);\r\n};\r\n\r\n/*NodeJS method*/\r\nPromise.prototype.wait = function(){\r\n\treturn exports.wait(this);\r\n};\r\n\r\nDeferred.prototype = Promise.prototype;\r\n// A deferred provides an API for creating and resolving a promise.\r\nexports.Promise = exports.Deferred = exports.defer = defer;\r\nfunction defer(canceller){\r\n\treturn new Deferred(canceller);\r\n}\r\n\r\n\r\n// currentContext can be set to other values\r\n// and mirrors the global. We need to go off the global in case of multiple instances\r\n// of this module, which isn't rare with NPM's package policy.\r\nObject.defineProperty && Object.defineProperty(exports, \"currentContext\", {\r\n\tset: function(value){\r\n\t\tcurrentContext = value;\r\n\t},\r\n\tget: function(){\r\n\t\treturn currentContext;\r\n\t}\r\n});\r\nexports.currentContext = null;\r\n\r\n\r\nfunction Deferred(canceller){\r\n\tvar result, finished, isError, waiting = [], handled;\r\n\tvar promise = this.promise = new Promise();\r\n\tvar context = exports.currentContext;\r\n\r\n\tfunction notifyAll(value){\r\n\t\tvar previousContext = exports.currentContext;\r\n\t\tif(finished){\r\n\t\t\tthrow new Error(\"This deferred has already been resolved\");\r\n\t\t}\r\n\t\ttry{\r\n\t\t\tif(previousContext !== context){\r\n\t\t\t\tif(previousContext && previousContext.suspend){\r\n\t\t\t\t\tpreviousContext.suspend();\r\n\t\t\t\t}\r\n\t\t\t\texports.currentContext = context;\r\n\t\t\t\tif(context && context.resume){\r\n\t\t\t\t\tcontext.resume();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tresult = value;\r\n\t\t\tfinished = true;\r\n\t\t\tfor(var i = 0; i < waiting.length; i++){\r\n\t\t\t\tnotify(waiting[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfinally{\r\n\t\t\tif(previousContext !== context){\r\n\t\t\t\tif(context && context.suspend){\r\n\t\t\t\t\tcontext.suspend();\r\n\t\t\t\t}\r\n\t\t\t\tif(previousContext && previousContext.resume){\r\n\t\t\t\t\tpreviousContext.resume();\r\n\t\t\t\t}\r\n\t\t\t\texports.currentContext = previousContext;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfunction notify(listener){\r\n\t\tvar func = (isError ? listener.error : listener.resolved);\r\n\t\tif(func){\r\n\t\t\thandled ?\r\n\t\t\t\t(handled.handled = true) : (handled = true);\r\n\t\t\t\ttry{\r\n\t\t\t\t\tvar newResult = func(result);\r\n\t\t\t\t\tif(newResult && typeof newResult.then === \"function\"){\r\n\t\t\t\t\t\tnewResult.then(listener.deferred.resolve, listener.deferred.reject);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlistener.deferred.resolve(newResult);\r\n\t\t\t\t}\r\n\t\t\t\tcatch(e){\r\n\t\t\t\t\tlistener.deferred.reject(e);\r\n\t\t\t\t}\r\n\t\t}\r\n\t\telse{\r\n\t\t\tif(isError){\r\n\t\t\t\tlistener.deferred.reject(result, typeof handled === \"object\" ? handled : (handled = {}));\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tlistener.deferred.resolve.call(listener.deferred, result);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// calling resolve will resolve the promise\r\n\tthis.resolve = this.callback = this.emitSuccess = function(value){\r\n\t\tnotifyAll(value);\r\n\t};\r\n\r\n\t// calling error will indicate that the promise failed\r\n\tvar reject = this.reject = this.errback = this.emitError = function(error, handledObject){\r\n\t\tif (typeof handledObject == \"object\") {\r\n\t\t\tif (handled) {\r\n\t\t\t\thandledObject.handled = true;\r\n\t\t\t} else {\r\n\t\t\t\thandled = handledObject;\r\n\t\t\t}\r\n\t\t}\r\n\t\tisError = true;\r\n\t\tnotifyAll(error);\r\n\t\tif (!handledObject && typeof setTimeout !== \"undefined\") {\r\n\t\t\tif (!(typeof handled == \"object\" ? handled.handled : handled)) {\r\n\t\t\t\t// set the time out if it has not already been handled\r\n\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\tif (!(typeof handled == \"object\" ? handled.handled : handled)) {\r\n\t\t\t\t\t\tthrow error;\r\n\t\t\t\t\t}\r\n\t\t\t\t}, exports.errorTimeout);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn handled;\r\n\t};\r\n\r\n\t// call progress to provide updates on the progress on the completion of the promise\r\n\tthis.progress = function(update){\r\n\t\tfor(var i = 0; i < waiting.length; i++){\r\n\t\t\tvar progress = waiting[i].progress;\r\n\t\t\tprogress && progress(update);\r\n\t\t}\r\n\t}\r\n\t// provide the implementation of the promise\r\n\tthis.then = promise.then = function(resolvedCallback, errorCallback, progressCallback){\r\n\t\tvar returnDeferred = new Deferred(promise.cancel);\r\n\t\tvar listener = {resolved: resolvedCallback, error: errorCallback, progress: progressCallback, deferred: returnDeferred};\r\n\t\tif(finished){\r\n\t\t\tnotify(listener);\r\n\t\t}\r\n\t\telse{\r\n\t\t\twaiting.push(listener);\r\n\t\t}\r\n\t\treturn returnDeferred.promise;\r\n\t};\r\n\tvar timeout;\r\n\tif(typeof setTimeout !== \"undefined\") {\r\n\t\tthis.timeout = function (ms) {\r\n\t\t\tif (ms === undefined) {\r\n\t\t\t\treturn timeout;\r\n\t\t\t}\r\n\t\t\ttimeout = ms;\r\n\t\t\tsetTimeout(function () {\r\n\t\t\t\tif (!finished) {\r\n\t\t\t\t\tif (promise.cancel) {\r\n\t\t\t\t\t\tpromise.cancel(new Error(\"timeout\"));\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\treject(new Error(\"timeout\"));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}, ms);\r\n\t\t\treturn promise;\r\n\t\t};\r\n\t}\r\n\r\n\tif(canceller){\r\n\t\tthis.cancel = promise.cancel = function(){\r\n\t\t\tvar error = canceller();\r\n\t\t\tif(!(error instanceof Error)){\r\n\t\t\t\terror = new Error(error);\r\n\t\t\t}\r\n\t\t\treject(error);\r\n\t\t}\r\n\t}\r\n\tfreeze(promise);\r\n};\r\n\r\nfunction perform(value, async, sync){\r\n\ttry{\r\n\t\tif(value && typeof value.then === \"function\"){\r\n\t\t\tvalue = async(value);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tvalue = sync(value);\r\n\t\t}\r\n\t\tif(value && typeof value.then === \"function\"){\r\n\t\t\treturn value;\r\n\t\t}\r\n\t\tvar deferred = new Deferred();\r\n\t\tdeferred.resolve(value);\r\n\t\treturn deferred.promise;\r\n\t}catch(e){\r\n\t\tvar deferred = new Deferred();\r\n\t\tdeferred.reject(e);\r\n\t\treturn deferred.promise;\r\n\t}\r\n\r\n}\r\n/**\r\n * Promise manager to make it easier to consume promises\r\n */\r\n\r\nfunction rethrow(err){ throw err; }\r\n\r\n/**\r\n * Registers an observer on a promise, always returning a promise\r\n * @param value\t\t promise or value to observe\r\n * @param resolvedCallback function to be called with the resolved value\r\n * @param rejectCallback\tfunction to be called with the rejection reason\r\n * @param progressCallback\tfunction to be called when progress is made\r\n * @return promise for the return value from the invoked callback\r\n */\r\nexports.whenPromise = function(value, resolvedCallback, rejectCallback, progressCallback){\r\n\tvar deferred = defer();\r\n\tif(value && typeof value.then === \"function\"){\r\n\t\tvalue.then(function(next){\r\n\t\t\tdeferred.resolve(next);\r\n\t\t},function(error){\r\n\t\t\tdeferred.reject(error);\r\n\t\t});\r\n\t\trejectCallback = rejectCallback || rethrow;\r\n\t}else{\r\n\t\tdeferred.resolve(value);\r\n\t}\r\n\treturn deferred.promise.then(resolvedCallback, rejectCallback, progressCallback);\r\n};\r\n\r\n/**\r\n * Registers an observer on a promise.\r\n * @param value\t\t promise or value to observe\r\n * @param resolvedCallback function to be called with the resolved value\r\n * @param rejectCallback\tfunction to be called with the rejection reason\r\n * @param progressCallback\tfunction to be called when progress is made\r\n * @return promise for the return value from the invoked callback or the value if it\r\n * is a non-promise value\r\n */\r\nexports.when = function(value, resolvedCallback, rejectCallback, progressCallback){\r\n\t\tif(value && typeof value.then === \"function\"){\r\n\t\t\t\tif(value instanceof Promise){\r\n\t\t\t\t\t\treturn value.then(resolvedCallback, rejectCallback, progressCallback);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\t\treturn exports.whenPromise(value, resolvedCallback, rejectCallback, progressCallback);\r\n\t\t\t\t}\r\n\t\t}\r\n\t\treturn resolvedCallback ? resolvedCallback(value) : value;\r\n};\r\n\r\n/**\r\n * This is convenience function for catching synchronously and asynchronously thrown\r\n * errors. This is used like when() except you execute the initial action in a callback:\r\n * whenCall(function(){\r\n *   return doSomethingThatMayReturnAPromise();\r\n * }, successHandler, errorHandler);\r\n */\r\nexports.whenCall = function(initialCallback, resolvedCallback, rejectCallback, progressCallback){\r\n\ttry{\r\n\t\treturn exports.when(initialCallback(), resolvedCallback, rejectCallback, progressCallback);\r\n\t}catch(e){\r\n\t\treturn rejectCallback(e);\r\n\t}\r\n}\r\n\r\n/**\r\n * Gets the value of a property in a future turn.\r\n * @param target\tpromise or value for target object\r\n * @param property\t\tname of property to get\r\n * @return promise for the property value\r\n */\r\nexports.get = function(target, property){\r\n\treturn perform(target, function(target){\r\n\t\treturn target.get(property);\r\n\t},\r\n\tfunction(target){\r\n\t\treturn target[property]\r\n\t});\r\n};\r\n\r\n/**\r\n * Invokes a method in a future turn.\r\n * @param target\tpromise or value for target object\r\n * @param methodName\t\tname of method to invoke\r\n * @param args\t\tarray of invocation arguments\r\n * @return promise for the return value\r\n */\r\nexports.call = function(target, methodName, args){\r\n\treturn perform(target, function(target){\r\n\t\treturn target.call(methodName, args);\r\n\t},\r\n\tfunction(target){\r\n\t\treturn target[methodName].apply(target, args);\r\n\t});\r\n};\r\n\r\n/**\r\n * Sets the value of a property in a future turn.\r\n * @param target\tpromise or value for target object\r\n * @param property\t\tname of property to set\r\n * @param value\t new value of property\r\n * @return promise for the return value\r\n */\r\nexports.put = function(target, property, value){\r\n\treturn perform(target, function(target){\r\n\t\treturn target.put(property, value);\r\n\t},\r\n\tfunction(target){\r\n\t\treturn target[property] = value;\r\n\t});\r\n};\r\n\r\n\r\n/**\r\n * Waits for the given promise to finish, blocking (and executing other events)\r\n * if necessary to wait for the promise to finish. If target is not a promise\r\n * it will return the target immediately. If the promise results in an reject,\r\n * that reject will be thrown.\r\n * @param target\t promise or value to wait for.\r\n * @return the value of the promise;\r\n */\r\nvar queue;\r\n//try {\r\n//\t\tqueue = require(\"event-loop\");\r\n//}\r\n//catch (e) {}\r\nexports.wait = function(target){\r\n\tif(!queue){\r\n\t\tthrow new Error(\"Can not wait, the event-queue module is not available\");\r\n\t}\r\n\tif(target && typeof target.then === \"function\"){\r\n\t\tvar isFinished, isError, result;\r\n\t\ttarget.then(function(value){\r\n\t\t\tisFinished = true;\r\n\t\t\tresult = value;\r\n\t\t},\r\n\t\tfunction(error){\r\n\t\t\tisFinished = true;\r\n\t\t\tisError = true;\r\n\t\t\tresult = error;\r\n\t\t});\r\n\t\twhile(!isFinished){\r\n\t\t\tqueue.processNextEvent(true);\r\n\t\t}\r\n\t\tif(isError){\r\n\t\t\tthrow result;\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\telse{\r\n\t\treturn target;\r\n\t}\r\n};\r\n\r\n\r\n\r\n/**\r\n * Takes an array of promises and returns a promise that is fulfilled once all\r\n * the promises in the array are fulfilled\r\n * @param array\tThe array of promises\r\n * @return the promise that is fulfilled when all the array is fulfilled, resolved to the array of results\r\n */\r\nexports.all = function(array){\r\n\tvar deferred = new Deferred();\r\n\tif(Object.prototype.toString.call(array) !== '[object Array]'){\r\n\t\tarray = Array.prototype.slice.call(arguments);\r\n\t}\r\n\tvar fulfilled = 0, length = array.length, rejected = false;\r\n\tvar results = [];\r\n\tif (length === 0) deferred.resolve(results);\r\n\telse {\r\n\t\tarray.forEach(function(promise, index){\r\n\t\t\texports.when(promise,\r\n\t\t\t\tfunction(value){\r\n\t\t\t\t\tresults[index] = value;\r\n\t\t\t\t\tfulfilled++;\r\n\t\t\t\t\tif(fulfilled === length){\r\n\t\t\t\t\t\tdeferred.resolve(results);\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tfunction(error){\r\n\t\t\t\t\tif(!rejected){\r\n\t\t\t\t\t\t deferred.reject(error);\r\n\t\t\t\t\t}\r\n\t\t\t\t\trejected = true;\r\n\t\t\t\t});\r\n\t\t});\r\n\t}\r\n\treturn deferred.promise;\r\n};\r\n\r\n/**\r\n * Takes a hash of promises and returns a promise that is fulfilled once all\r\n * the promises in the hash keys are fulfilled\r\n * @param hash\tThe hash of promises\r\n * @return the promise that is fulfilled when all the hash keys is fulfilled, resolved to the hash of results\r\n */\r\nexports.allKeys = function(hash){\r\n\tvar deferred = new Deferred();\r\n\tvar array = Object.keys(hash);\r\n\tvar fulfilled = 0, length = array.length;\r\n\tvar results = {};\r\n\tif (length === 0) deferred.resolve(results);\r\n\telse {\r\n\t\tarray.forEach(function(key){\r\n\t\t\texports.when(hash[key],\r\n\t\t\t\tfunction(value){\r\n\t\t\t\t\tresults[key] = value;\r\n\t\t\t\t\tfulfilled++;\r\n\t\t\t\t\tif(fulfilled === length){\r\n\t\t\t\t\t\tdeferred.resolve(results);\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tdeferred.reject);\r\n\t\t});\r\n\t}\r\n\treturn deferred.promise;\r\n};\r\n\r\n/**\r\n * Takes an array of promises and returns a promise that is fulfilled when the first\r\n * promise in the array of promises is fulfilled\r\n * @param array\tThe array of promises\r\n * @return a promise that is fulfilled with the value of the value of first promise to be fulfilled\r\n */\r\nexports.first = function(array){\r\n\tvar deferred = new Deferred();\r\n\tif(Object.prototype.toString.call(array) !== '[object Array]'){\r\n\t\tarray = Array.prototype.slice.call(arguments);\r\n\t}\r\n\tvar fulfilled;\r\n\tarray.forEach(function(promise, index){\r\n\t\texports.when(promise, function(value){\r\n\t\t\tif (!fulfilled) {\r\n\t\t\t\tfulfilled = true;\r\n\t\t\t\tdeferred.resolve(value);\r\n\t\t\t}\r\n\t\t},\r\n\t\tfunction(error){\r\n\t\t\tif (!fulfilled) {\r\n\t\t\t\tfulfilled = true;\r\n\t\t\t\tdeferred.resolve(error);\r\n\t\t\t}\r\n\t\t});\r\n\t});\r\n\treturn deferred.promise;\r\n};\r\n\r\n/**\r\n * Takes an array of asynchronous functions (that return promises) and\r\n * executes them sequentially. Each funtion is called with the return value of the last function\r\n * @param array\tThe array of function\r\n * @param startingValue The value to pass to the first function\r\n * @return the value returned from the last function\r\n */\r\nexports.seq = function(array, startingValue){\r\n\tarray = array.concat(); // make a copy\r\n\tvar deferred = new Deferred();\r\n\tfunction next(value){\r\n\t\tvar nextAction = array.shift();\r\n\t\tif(nextAction){\r\n\t\t\texports.when(nextAction(value), next, function(error){\r\n\t\t\t  deferred.reject(error, true);\r\n\t\t\t});\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdeferred.resolve(value);\r\n\t\t}\r\n\t}\r\n\tnext(startingValue);\r\n\treturn deferred.promise;\r\n};\r\n\r\n\r\n/**\r\n * Delays for a given amount of time and then fulfills the returned promise.\r\n * @param milliseconds The number of milliseconds to delay\r\n * @return A promise that will be fulfilled after the delay\r\n */\r\nif(typeof setTimeout !== \"undefined\") {\r\n\texports.delay = function(milliseconds) {\r\n\t\tvar deferred = new Deferred();\r\n\t\tsetTimeout(function(){\r\n\t\t\tdeferred.resolve();\r\n\t\t}, milliseconds);\r\n\t\treturn deferred.promise;\r\n\t};\r\n}\r\n\r\n\r\n\r\n/**\r\n * Runs a function that takes a callback, but returns a Promise instead.\r\n * @param func\t node compatible async function which takes a callback as its last argument\r\n * @return promise for the return value from the callback from the function\r\n */\r\nexports.execute = function(asyncFunction){\r\n\tvar args = Array.prototype.slice.call(arguments, 1);\r\n\r\n\tvar deferred = new Deferred();\r\n\targs.push(function(error, result){\r\n\t\tif(error) {\r\n\t\t\tdeferred.emitError(error);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif(arguments.length > 2){\r\n\t\t\t\t// if there are multiple success values, we return an array\r\n\t\t\t\tArray.prototype.shift.call(arguments, 1);\r\n\t\t\t\tdeferred.emitSuccess(arguments);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tdeferred.emitSuccess(result);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\tasyncFunction.apply(this, args);\r\n\treturn deferred.promise;\r\n};\r\n\r\nfunction isGeneratorFunction(obj){\r\n\treturn obj && obj.constructor && 'GeneratorFunction' == obj.constructor.name;\r\n}\r\n\r\n/**\r\n * Promise-based coroutine trampoline\r\n * Adapted from https://github.com/deanlandolt/copromise/blob/master/copromise.js\r\n */\r\nfunction run(coroutine){\r\n\tvar deferred = defer();\r\n\t(function next(value, exception) {\r\n\t\tvar result;\r\n\t\ttry {\r\n\t\t\tresult = exception ? coroutine.throw(value) : coroutine.next(value);\r\n\t\t}\r\n\t\tcatch (error) {\r\n\t\t\treturn deferred.reject(error);\r\n\t\t}\r\n\t\tif (result.done) return deferred.resolve(result.value);\r\n\t\texports.when(result.value, next, function(error) {\r\n\t\t\tnext(error, true);\r\n\t\t});\r\n\t})();\r\n\treturn deferred.promise;\r\n};\r\n\r\n/**\r\n * Creates a task from a coroutine, provided as generator. The `yield` function can be provided\r\n * a promise (or any value) to wait on, and the value will be provided when the promise resolves.\r\n * @param coroutine\t generator or generator function to treat as a coroutine\r\n * @return promise for the return value from the coroutine\r\n */\r\nexports.spawn = function(coroutine){\r\n\tif (isGeneratorFunction(coroutine)) {\r\n\t\tcoroutine = coroutine();\r\n\t}\r\n\treturn run(coroutine);\r\n}\r\n\r\n/**\r\n * Converts a Node async function to a promise returning function\r\n * @param func\t node compatible async function which takes a callback as its last argument\r\n * @return A function that returns a promise\r\n */\r\nexports.convertNodeAsyncFunction = function(asyncFunction, callbackNotDeclared){\r\n\tvar arity = asyncFunction.length;\r\n\treturn function(){\r\n\t\tvar deferred = new Deferred();\r\n\t\tif(callbackNotDeclared){\r\n\t\t\tarity = arguments.length + 1;\r\n\t\t}\r\n\t\targuments.length = arity;\r\n\t\targuments[arity - 1] = function(error, result){\r\n\t\t\tif(error) {\r\n\t\t\t\tdeferred.emitError(error);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif(arguments.length > 2){\r\n\t\t\t\t\t// if there are multiple success values, we return an array\r\n\t\t\t\t\tArray.prototype.shift.call(arguments, 1);\r\n\t\t\t\t\tdeferred.emitSuccess(arguments);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tdeferred.emitSuccess(result);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tasyncFunction.apply(this, arguments);\r\n\t\treturn deferred.promise;\r\n\t};\r\n};\r\n\r\n/**\r\n * Returns a promise. If the object is already a Promise it is returned; otherwise\r\n * the object is wrapped in a Promise.\r\n * @param value\t The value to be treated as a Promise\r\n * @return A promise wrapping the original value\r\n */\r\nexports.as = function(value){\r\n\tif (value instanceof Promise) {\r\n\t\treturn value;\r\n\t} else {\r\n\t\tvar ret = defer();\r\n\t\tret.resolve(value);\r\n\t\treturn ret;\r\n\t}\r\n};\r\n});\r\n})(typeof define!=\"undefined\"?define:function(factory){factory(require,exports)});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/promised-io/promise.js\n// module id = 5\n// module chunks = 0 1","module.exports = function() {\r\n\tthrow new Error(\"define cannot be used indirect\");\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/amd-define.js\n// module id = 6\n// module chunks = 0 1"],"sourceRoot":""}